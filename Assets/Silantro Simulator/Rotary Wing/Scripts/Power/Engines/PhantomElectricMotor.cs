using Oyedoyin;
using UnityEngine;
using System.Collections;



public class PhantomElectricMotor : MonoBehaviour
{
    // ------------------------------------- Core
    public float ratedRPM = 2000f;
    public float coreRPM;
    public enum MotorState { Off, Running }
    public MotorState motorState = MotorState.Off;
    public float corePower, coreFactor;
    [Range(0.01f, 1f)] public float baseCoreAcceleration = 0.25f;


    // ------------------------------------- Sounds
    public AudioClip runningSound;
    private AudioSource motorSource;
    public float maximumPitch = 1.5f;
    public float maximumVolume = 0.7f;



    // ------------------------------------- Controls
    public bool start;
    public bool stop;
    [Range(0.1f, 1f)] public float controlInput;
    public bool active;


    // ------------------------------------- Power
    public float ratedVoltage = 50f;
    public float Kv = 100f;
    public float windingResistance = 0.013f;
    public float Kt;
    public float appliedTorque;
    public float motorCurrent;
    public float Vrms; //rms voltage applied to motor circuit
    public float Vemf; //motor EMF


    public float batteryVoltage = 45f;
    public float ecsResistance = 0.01f;
    public float seriesResistance = 0.01f;
    public float voltageLimit;


    // ------------------------------------- Output
    public float electricalPowerConsumed;
    public float mechanicalPowerDelivered;
    public bool torqueEngaged;

    public PhantomBattery battery;
    public PhantomController controller;


    // ----------------------------------------------------------------------------------------------------------------------------------------------------------
    private void Update()
    {
        if (battery)
        {
            if (active)
            {
                batteryVoltage = battery.outputVoltage;
                battery.outputCurrent = motorCurrent;
            }
            else { batteryVoltage = 0f; battery.outputCurrent = 0f; }
        }


        UpdateCore();

        UpdatePower();
    }





    // ----------------------------------------------------------------------------------------------------------------------------------------------------------
    public void StartMotor()  { active = true; StateRunning();  motorState = MotorState.Running; }
    public void StopMotor() { active = false;stop = true; }
    public IEnumerator ReturnIgnition() { yield return new WaitForSeconds(0.5f); start = false; stop = false; }

    public void InitializeMotor()
    {
        GameObject soundPoint = new GameObject("_sources"); soundPoint.transform.parent = transform; soundPoint.transform.localPosition = Vector3.zero;
        if (runningSound) { Handler.SetupSoundSource(soundPoint.transform, runningSound, "_motor_sound", 80f, true, true, out motorSource); }
        Kt = 1 / Kv;
    }





    // ----------------------------------------------------------------------------------------------------------------------------------------------------------
    void UpdateCore()
    {
        if (controller != null)
        {
            if (active) { if (corePower < 1f) { corePower += Time.fixedDeltaTime * baseCoreAcceleration; } }
            else if (corePower > 0f) { corePower -= Time.fixedDeltaTime * baseCoreAcceleration; }
            if (controlInput > 1) { controlInput = 1f; }
            if (controlInput < 0.1f) { controlInput = 0.1f; }
            if (corePower > 1) { corePower = 1f; }
            if (!active && corePower < 0) { corePower = 0f; }
            if (active && controller.batteryLevel < 1) { StopMotor(); }


            // ---------------------------------- State
            switch (motorState)
            {
                case MotorState.Off: StateOff(); break;
                case MotorState.Running: StateRunning(); break;
            }


            // ---------------------------------- Sound
            coreFactor = coreRPM / ratedRPM;
            motorSource.volume = coreFactor * corePower * maximumVolume;
            motorSource.pitch = coreFactor * corePower * maximumPitch;
        }
    }




    // ----------------------------------------------------------------------------------------------------------------------------------------------------------
    void UpdatePower()
    {
        //the user control input => ESC => direct modulation of the Vrms by PWM of the instanteous available battery open circuit voltage which depends on current battery state of charge.
        Vrms = controlInput * batteryVoltage;// battery.getVoc();

        //RMS back emf generated by the motor will be directly proportional to Kv
        Vemf = coreRPM / Kv * 0.7071f;

        //motorCurrent is (applied RMS voltage - back emf) / (sum of circuit resistances)
        motorCurrent = (Vrms - Vemf) / (seriesResistance + ecsResistance + windingResistance);
        voltageLimit = Vrms - Vemf - motorCurrent * (seriesResistance + ecsResistance);
       
        
        // check if the voltage at the motor terminals exceeds rated voltage. This can be turned off when not in debug mode. 
        if (voltageLimit >= ratedVoltage)
        {
            Debug.Log("Instantaneous applied motor voltage " + Vrms + "[V] exceeds motor rated voltage = " + ratedVoltage + "[V]");
        }

        // we can then compute the torque applied to the rotor by the motor as we know the current and torque constant
        appliedTorque = Kt * motorCurrent;

        // with the applied torque I assume this changes the RPM of the rotor via the rotor model as I believe it must depend on prop pitch and collective, here I assume a function that returns a new coreRPM from the current coreRPM and appliedTorque 
        if(!torqueEngaged) { coreRPM = Vrms * Kv; }
        else
        {
            coreRPM = (30f * mechanicalPowerDelivered * 1000) / (appliedTorque * 3.142f);
            coreRPM = Mathf.Clamp(coreRPM, 0, ratedRPM);
        }
        
        //electrical power delivered by the battery 
        electricalPowerConsumed = Vrms * motorCurrent;

        //mechanical power delivered to the shaft
        mechanicalPowerDelivered = appliedTorque * coreRPM / 9.5488f;
    }



    // ----------------------------------------------------------------------------------------------------------------------------------------------------------
    private void StateOff()
    {
        if (start) { active = true; coreRPM = ratedRPM; motorState = MotorState.Running; StartCoroutine(ReturnIgnition()); }
    }


    private void StateRunning()
    {
        if (stop) { motorState = MotorState.Off; active = false; StartCoroutine(ReturnIgnition()); }
    }
}
